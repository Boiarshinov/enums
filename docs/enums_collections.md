# Перечисления в Java

## Содержание
- Коллекции перечислений
    - Множество `EnumSet`
    - Отображение `EnumMap`

## Коллекции перечислений
О преимуществах использования коллекций, специализированных для перечислений,
пишет многие известные Java-разработчики: Джошуа Блох, [Тагир Валеев][Tagir] и др.
Коллекции перечислений появились в Java одновременно с перечислениями.

### Множество `EnumSet`
При рассмотрении множеств перечислений в примерах будет использоваться 
следующий класс:
```java
public enum ProfileType {
    GUEST, USER, MODERATOR, ADMIN
}
```  

Для создания экземпляров множеств `EnumSet` используются только статические методы,
объявленные в этом классе: 
- `of()` - создает множество из переданных перечислений одного типа;
- `allOf()` - создает множество из всех элементов указанного типа перечисления;
- `noneOf()` - создает пустое множество элементов указанного типа перечисления;
- `range()` - создает множество перечислений, начиная и заканчивая 
указанными элементами.
```java
EnumSet<ProfileType> onlyStaff = EnumSet.of(ProfileType.ADMIN, ProfileType.MODERATOR);
EnumSet<ProfileType> all = EnumSet.allOf(ProfileType.class);
EnumSet<ProfileType> empty = EnumSet.noneOf(ProfileType.class);
EnumSet<ProfileType> rangeSet = EnumSet.range(ProfileType.GUEST, ProfileType.MODERATOR);
```
Метод `range()` применять опасно, так как при изменении порядка элементов 
перечисления метод может начать работать не так, как ожидается, либо вообще 
будет падать с исключением.
Сообщение исключения при этом будет нести мало смысла:
```
java.lang.IllegalArgumentException: MODERATOR > GUEST
```

Есть еще два метода, позволяющие создать новый экземпляр множества 
на основе существующего:
- `complementOf()` - создает множество, содержащее элементы, 
отсутствующие в исходном множестве
- `copyOf()` - копирует переданное множество перечислений 
```java
EnumSet<ProfileType> onlyClients = EnumSet.complementOf(onlyStaff);
EnumSet<ProfileType> copiedSet = EnumSet.copyOf(onlyClients);
```

Класс `EnumSet` является абстрактным и у него два наследника:
- `RegularEnumSet`
- `JumboEnumSet`

//картинка UML-диаграммы с данными классами. (добавить туда приватные классы итераторов)

Объект какого класса создастся при вызове одного из статических методов генерации,
зависит от количества элементов перечисления. Если в перечислении объявлено не
больше 64 элементов, то будет создан объект класса `RegularEnumSet`, 
в ином случае - `JumboEnumSet`.
Наследники являются package-private, поэтому выбрать нужную реализацию 
самостоятельно не получится.

#### Реализация `RegularEnumSet`
`RegularEnumSet` представляет собой битовую маску, выраженную с помощью 64-битного целого числа
```java
class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {
  private long elements = 0L;
  /* ... */
}
```
<mark>Картинка с битовой маской</mark>

Каждому значению перечисления соответствует один бит.
Номер бита равен значению `ordinal()` данного перечисления.

<mark>Картинка с соответствием перечислений битам</mark>

Для работы с данной коллекцией используются битовые операции.
Именно благодаря этому достигается существенное улучшение производительности по сравнению с обычным `HashSet`.
Рассмотрим к примеру добавление в коллекцию нового элемента.

<mark>Последовательность картинок</mark>

Единица типа `long` сдвигается влево столько раз, сколько возвращает метод `ordinal()` для значения перечисления.
После чего происходит дезъюнкция битовых масок.

Также рассмотрим проверку на вхождение перечисления в коллекцию.

<mark>Последовательность картинок</mark>

Проверяемое значение перечисления опять преобразуется в битовую маску путем побитового сдвига единички.
Затем вычисляется конъюнкция этой битовой маски с битовой маской коллекции.
Если результат не равен нулю, то элемент присутствует в коллекции.

#### Реализация `JumboEnumSet`
`JumboEnumSet` служит для перечислений, в которых больше 64 значений. 
В этом случае битовой маски размером в 64 бита уже не хватает и потому используется массив 64-битных целых чисел:
```java
class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {
  private long elements[];
  /* ... */
}
```
<mark>Картинка с массивом битовых масок</mark>

Работа с этой коллекцией подобна `RegularEnumSet` с поправкой на использование массивов.

### Отображение `EnumMap`
<mark>todo</mark>

    
## Список источников
- библиотеки `java.lang`, `java.util`
- Джошуа Блох. Java. Эффективное программирование - 2017 г.
- Тагир Валеев. [Коллекции в Java: о чем многие забывают][Tagir]
- Vlad Mihalcea. [The best way to map an Enum Type with JPA and Hibernate][Mihalcea]



[Tagir]: https://habr.com/ru/post/267389/
[Mihalcea]: https://vladmihalcea.com/the-best-way-to-map-an-enum-type-with-jpa-and-hibernate/