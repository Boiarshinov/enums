# Вступление для доклада

Многие пришедшие на этот доклад могут думать: "Что нового можно сказать про перечисления? Я пользуюсь ими каждый день и знаю о них наверное все".
Позволю себе усомниться в этом.

Для того чтобы заинтересовать вас, я задам вам несколько вопросов о перечислениях.
Приводить ответы на эти вопросы я не буду (а то вдруг вы начнете задавать такие вопросы на собеседованиях c:), но если вы сильно захотите узнать ответы, то можете подойти ко мне после доклада.

## Порядок выполнения кодовых блоков

Что будет выведено в консоль?
```java
public class App {
    public static void main(String[] args) {
        System.out.print("A ");
        var enumInit = EnumInit.ONE;
    }

    enum EnumInit {
        ONE;

        static {
            System.out.print("B ");
        }

        {
            System.out.print("C ");
        }

        EnumInit() {
            System.out.print("D ");
        }
    }
}
```

1) A B C D
2) B A C D
3) B C D A
4) A C D B

Правильный ответ - 4.
Это значит, что перечисления инициализируются лениво, а обычные кодовые блоки и конструкторы исполняются раньше статических блоков.
Но почему так?

## Несуществующие методы

Если вы откроете класс `Enum`, то увидите в нем следующие публичные методы:
```java
String name();
int ordinal();
Class<E> getDeclaringClass();
int compareTo(E o);
static <T extends Enum<T>> T valueOf(Class<T> enumType, String name);
/* Методы класса Object */
```
То же самое мы увидим в [документации Oracle](https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html).

Подождите, но я точно помню, что использовал еще и статические методы `values()`, `valueOf(String name)`
```java
DayOfWeek[] values = DayOfWeek.values();
DayOfWeek sunday = DayOfWeek.valueOf("SUNDAY");
```
Куда же они пропали?

## Рекурсивная типизация

Дженерики и перечисления появились в Java одновременно.
Джошуа Блох оторвался и сделал класс `Enum` рекурсивно обобщенным:
```java
public abstract class Enum<E extends Enum<E>>
```
Это вообще как?
Как компилятор не спотыкается, пытаясь разрулить рекурсию типов?
Что изменится, если убрать одно из обобщений?
```java
public abstract class Enum<E extends Enum>
```

## Ответы:

**Порядок выполнения кодовых блоков**: Дело в том, что при компиляции все конструкторы и нестатические блоки 
в перечислениях преобразуются в статические блоки, которые устанавливаются в самой вершине генерируемого класса.
Поэтому они исполняются раньше статического блока.
Примерно так будет выглядеть 
```java
class EnumInit extends Enum<EnumInit> {
    static { //Преобразовано из нестатического блока
        System.out.print("C ");
    }
    public static EnumInit ONE = new EnumInit();
    static { //Преобразовано из конструктора
        System.out.print("D ");
    }
    
    static { //Оставшийся статический блок
        System.out.print("B ");
    }
    /* ... */
}
```

**Несуществующие методы**: согласно [спецификации Java](https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9.3) эти два метода являются неявно объявленными.
Их реализация создается на этапе компиляции отдельно для каждого перечисления.

**Рекурсивная типизация**: <mark>todo</mark>